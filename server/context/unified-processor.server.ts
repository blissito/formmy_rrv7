/**
 * Unified Context Processor - Single Source of Truth
 *
 * Consolida 3 flujos diferentes de vectorizaci√≥n en UNA funci√≥n central:
 * 1. Parser API (job.service.ts)
 * 2. UI LlamaParse (embedding.service.ts)
 * 3. UI Manual Upload (contextManager.server.ts)
 *
 * Garantiza:
 * - Estructura consistente de ContextItem (TODOS los campos presentes)
 * - Inserci√≥n at√≥mica con $push MongoDB
 * - Chunking optimizado (2000 chars, 100 overlap = 5%)
 * - Deduplicaci√≥n sem√°ntica (85% threshold)
 */

import { db } from '~/utils/db.server';
import { generateEmbedding } from '../vector/embedding.service';
import type { ContextType } from '@prisma/client';
import {
  retryWithBackoff,
  chunkContent,
  isDuplicateChunk
} from '../vector/vector-utils.server';

/**
 * Par√°metros para agregar contexto
 */
export interface AddContextParams {
  chatbotId: string;
  content: string;
  metadata: {
    type: ContextType;

    // FILE espec√≠fico
    fileName?: string;
    fileType?: string;
    fileSize?: number;  // bytes (se convertir√° a KB)

    // LINK espec√≠fico
    url?: string;

    // TEXT/QUESTION espec√≠fico
    title?: string;

    // QUESTION espec√≠fico
    questions?: string;
    answer?: string;

    // Metadata adicional
    routes?: string[];

    // Override de ID (opcional, para parser jobs)
    contextId?: string;

    // Metadata de parsing (opcional, solo para Parser API)
    parsingMode?: string;    // "DEFAULT" | "COST_EFFECTIVE" | "AGENTIC" | "AGENTIC_PLUS"
    parsingPages?: number;
    parsingCredits?: number;
  };
}

/**
 * Resultado de agregar contexto
 */
export interface AddContextResult {
  success: boolean;
  contextId: string;
  embeddingsCreated: number;
  embeddingsSkipped: number;
  error?: string;
}

/**
 * Extrae texto procesable para vectorizaci√≥n seg√∫n tipo de contexto
 * Copia de auto-vectorize.service.ts para mantener l√≥gica consistente
 */
function extractTextFromContext(
  content: string,
  metadata: AddContextParams['metadata']
): string {
  const parts: string[] = [];

  // T√≠tulo siempre incluido si existe
  if (metadata.title) {
    parts.push(`# ${metadata.title}`);
  }

  // Contenido seg√∫n tipo
  switch (metadata.type) {
    case 'TEXT':
    case 'FILE':
    case 'LINK':
      if (content) {
        parts.push(content);
      }
      break;

    case 'QUESTION':
      if (metadata.questions) {
        parts.push(`Pregunta: ${metadata.questions}`);
      }
      if (metadata.answer) {
        parts.push(`Respuesta: ${metadata.answer}`);
      }
      // Tambi√©n incluir content si existe
      if (content) {
        parts.push(content);
      }
      break;
  }

  // Metadata adicional
  if (metadata.type === 'FILE' && metadata.fileName) {
    parts.push(`Archivo: ${metadata.fileName}`);
  }
  if (metadata.type === 'LINK' && metadata.url) {
    parts.push(`URL: ${metadata.url}`);
  }

  return parts.join('\n\n');
}

/**
 * Construye ContextItem completo y consistente
 * GARANTIZA que TODOS los campos est√©n presentes (usar null para no aplicables)
 */
function buildContextItem(params: AddContextParams) {
  const { metadata, content } = params;
  const sizeKB = Math.round(Buffer.byteLength(content, 'utf8') / 1024);

  // Generar ID √∫nico o usar el proporcionado
  const contextId = metadata.contextId || `ctx_${Date.now()}_${Math.random().toString(36).substring(7)}`;

  // Construir ContextItem con TODOS los campos
  return {
    id: contextId,
    type: metadata.type,

    // FILE espec√≠fico
    fileName: metadata.fileName || null,
    fileType: metadata.fileType || null,
    fileUrl: null, // TODO: Agregar soporte para fileUrl en el futuro

    // LINK espec√≠fico
    url: metadata.url || null,

    // TEXT/QUESTION espec√≠fico
    title: metadata.title || null,

    // QUESTION espec√≠fico
    questions: metadata.questions || null,
    answer: metadata.answer || null,

    // Comunes
    content,
    sizeKB,
    routes: metadata.routes || [],
    createdAt: new Date(),

    // Metadata de parsing (solo presente para docs parseados via Parser API)
    parsingMode: metadata.parsingMode || null,
    parsingPages: metadata.parsingPages || null,
    parsingCredits: metadata.parsingCredits || null,
  };
}

/**
 * FUNCI√ìN CENTRAL - √önica fuente de verdad
 *
 * Agrega contexto al chatbot con embeddings autom√°ticos:
 * 1. Construye ContextItem completo (TODOS los campos presentes)
 * 2. Inserta con $push at√≥mico MongoDB
 * 3. Divide en chunks optimizados
 * 4. Genera embeddings con deduplicaci√≥n sem√°ntica
 * 5. Inserta embeddings en MongoDB
 */
export async function addContextWithEmbeddings(
  params: AddContextParams
): Promise<AddContextResult> {
  const { chatbotId, content } = params;

  try {
    // 1. Validar contenido
    if (!content || content.trim().length === 0) {
      return {
        success: false,
        contextId: '',
        embeddingsCreated: 0,
        embeddingsSkipped: 0,
        error: 'No hay contenido para procesar',
      };
    }

    // 2. Validar que el chatbot existe
    const chatbot = await db.chatbot.findUnique({
      where: { id: chatbotId },
      select: { id: true },
    });

    if (!chatbot) {
      return {
        success: false,
        contextId: '',
        embeddingsCreated: 0,
        embeddingsSkipped: 0,
        error: `Chatbot ${chatbotId} no encontrado`,
      };
    }

    // 3. Construir ContextItem completo
    const contextItem = buildContextItem(params);
    console.log(`üìù Creating context ${contextItem.id} (type: ${contextItem.type})`);

    // 4. Insertar con $push at√≥mico (MongoDB)
    const { ObjectId } = await import('mongodb');

    await db.$runCommandRaw({
      update: 'Chatbot',
      updates: [
        {
          q: { _id: new ObjectId(chatbotId) },
          u: {
            $push: { contexts: contextItem },
            $inc: { contextSizeKB: contextItem.sizeKB }
          },
        },
      ],
    });

    console.log(`‚úÖ Context added to chatbot ${chatbotId}`);

    // 4. Extraer texto procesable seg√∫n tipo de contexto
    const textToVectorize = extractTextFromContext(content, params.metadata);

    // 5. Dividir en chunks
    const chunks = chunkContent(textToVectorize);
    console.log(`üìù Verificando y creando embeddings (${chunks.length} chunks)...`);

    let created = 0;
    let skipped = 0;

    // 6. Generar embeddings para cada chunk
    for (let i = 0; i < chunks.length; i++) {
      const chunk = chunks[i];

      try {
        // Generar embedding con retry
        const embedding = await retryWithBackoff(
          () => generateEmbedding(chunk),
          `Generating embedding for chunk ${i + 1}/${chunks.length}`
        );

        // Deduplicaci√≥n sem√°ntica
        const isDuplicate = await isDuplicateChunk(embedding, chatbotId);

        if (isDuplicate) {
          console.log(`‚è≠Ô∏è  Chunk ${i + 1}/${chunks.length} saltado (duplicado sem√°ntico)`);
          skipped++;
          continue;
        }

        // Construir metadata con fallbacks (igual que auto-vectorize)
        let title = contextItem.title;
        let fileName = contextItem.fileName;
        let url = contextItem.url;

        // Aplicar fallbacks seg√∫n el tipo de contexto
        switch (contextItem.type) {
          case 'FILE':
            // Para archivos, fileName es prioritario
            fileName = fileName || title || 'Unnamed file';
            break;
          case 'LINK':
            // Para links, title y url son prioritarios
            title = title || (url ? new URL(url).hostname : 'Unnamed link');
            break;
          case 'TEXT':
            // Para texto, title es prioritario
            title = title || 'Unnamed text';
            break;
          case 'QUESTION':
            // Para FAQs, usar la pregunta como title
            title = title || contextItem.questions || 'Unnamed question';
            break;
        }

        const embeddingMetadata: any = {
          contextId: contextItem.id,
          contextType: contextItem.type,
          title,
          fileName,
          url,
          chunkIndex: i,
          totalChunks: chunks.length,
          source: 'unified-processor',
        };

        // Insertar embedding
        await db.embedding.create({
          data: {
            chatbotId,
            content: chunk,
            embedding,
            metadata: embeddingMetadata,
          },
        });

        created++;
        console.log(`‚úÖ Chunk ${i + 1}/${chunks.length} agregado (√∫nico)`);
      } catch (chunkError) {
        console.error(`Error generando embedding para chunk ${i}:`, chunkError);
        // Continuar con los dem√°s chunks aunque falle uno
      }
    }

    console.log(
      `‚úÖ Resultado: ${created} creados, ${skipped} duplicados (de ${chunks.length} chunks totales)`
    );

    return {
      success: true,
      contextId: contextItem.id,
      embeddingsCreated: created,
      embeddingsSkipped: skipped,
    };
  } catch (error) {
    console.error('‚ùå Error en addContextWithEmbeddings:', error);
    return {
      success: false,
      contextId: '',
      embeddingsCreated: 0,
      embeddingsSkipped: 0,
      error: error instanceof Error ? error.message : 'Error desconocido',
    };
  }
}

/**
 * Elimina embeddings asociados a un contexto
 */
export async function removeContextEmbeddings(
  chatbotId: string,
  contextId: string
): Promise<number> {
  const result = await db.embedding.deleteMany({
    where: {
      chatbotId,
      metadata: {
        path: ['contextId'],
        equals: contextId,
      },
    },
  });

  return result.count;
}
